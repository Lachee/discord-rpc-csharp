{
  "articles/getting_started/monogame.html": {
    "href": "articles/getting_started/monogame.html",
    "title": "Mono Game Setup | Discord RPC C#",
    "keywords": "Mono Game Setup Currently no guide for Mono Game setup. Please follow the Standard Guide and include the follow files from the Unity Package: The Unity Named Pipes Library The Lachee/Discord-RPC-Unity Named Pipe Help Wanted Here Looking for those who have experience with Mono Game and implementing this library into their projects. If you have managed to successfully use this library in your project, please contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "articles/getting_started/standard.html": {
    "href": "articles/getting_started/standard.html",
    "title": "Standard | Discord RPC C#",
    "keywords": "Standard The standard guide for all .NET projects. Download First the library must be downloaded. For standard projects within the .NET enviorment, a nuget package is available and is updated to the latest release. PM> Install-Package DiscordRichPresence A build of the library itself can be located in the AppVeyor Artifacts Usage The library has 3 phases that must be followed, Initialization Rich Presence Setting Deinitialization and Disposal You can set the Rich Presence of your app at any time while the client object has been constructed. The client will store the state of the presence and automatically resend it once initialized again. Initialization The creation of the client should happen once in the lifetime of the app. Where you put the constructor is upto your application design principles, but in general its always a good idea to put it in your initializers. The client should be ideally treated like a singleton and only ever created once. Multiple instances of the client can conflict with each other and cause unpredictable results within Discord and the end users Rich Presence. public DiscordRpcClient Client { get; private set;} void Setup() { Client = new DiscordRpcClient(\"my_client_id\"); //Creates the client Client.Initialize(); //Connects the client } Note that the Initialize() can be called later and the current presence state will be re-sent to the Discord Client. Setting Rich Presence Setting Rich Presence is easy once the client has been initialized: //Set Presence client.SetPresence(new RichPresence() { Details = \"Example Project\", State = \"csharp example\", Assets = new Assets() { LargeImageKey = \"image_large\", LargeImageText = \"Lachee's Discord IPC Library\", SmallImageKey = \"image_small\" } }); You may call this as regularly as you wish, the default behaviour of the application will ignore duplicate presence and Discord itself will handle ratelimiting. With that said, its always a good idea to only set the presence when there is actual change, to avoid any overheads. Disposal It is important that the client is properly disposed when finished. This will safely disconnect from Discord and dispose of the resources correctly. If you have any issues with ghosting (particularly in Unity3D), make sure you dispose the client. //Dispose client void Cleanup() { client.Dispose(); } Events By defaults, events will be executed as they occur. This means they are executed on the RPC Thread , and not on the main. For most applications, this works fine and is treated as a normal event from any other library you may use. However, for applications where thread-safety is paramount (such as Game Engines), you may need to disable this feature and manually invoke events on your calling thread like so: void Start() { //Creates a new client, telling it not to automatically invoke the events on RPC thread. Client = new DiscordRpcClient(\"my_client_id\", autoEvents: false); Client.Initialize(); } void Update() { //Invoke the events once per-frame. The events will be executed on calling thread. Client.Invoke(); } Please note that this method is only required where cross-thread talk is a big no-no. Implementing this as a Timer would just defeat the purpose as they are threaded anyways . Further Reading If you wish to implement the Join and Spectate feature within your project (those buttons), please read Joining & Spectating Introduction to get started."
  },
  "articles/getting_started/unity3d.html": {
    "href": "articles/getting_started/unity3d.html",
    "title": "Unity3D | Discord RPC C#",
    "keywords": "Unity3D Please visit the documentation for Lachee/Discord-RPC-Unity"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Getting started with DiscordRPC C# | Discord RPC C#",
    "keywords": "Getting started with DiscordRPC C# Getting started with DiscordRPC-C# is easy! With automatic nuget packages and a fully fledge Unity3D package, you can get started in no time. Dependencies Newtonsoft.JSON .NET 3.5+ or Unity3D 5.5+ Select Project Type Standard .NET Project - Recommended. For most users that are making a .NET Application Lachee/Discord-RPC-Unity - For Unity3D users that want to add Rich Presence to their game. MonoGame Project / Modding / Godot - For developers using custom MonoGame engines or modding existing games. Need More Help? Still stuck? Make a new GitHub issue !"
  },
  "articles/join_spectate/intro.html": {
    "href": "articles/join_spectate/intro.html",
    "title": "Join / Spectate | Discord RPC C#",
    "keywords": "Join / Spectate Discord Rich Presence can serve as a form of match maker for your game. You can display a \"Join\" and \"Spectate\" button on your Rich Presence to allow people to connect directly through discord. Help Wanted Here Contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "articles/join_spectate/join.html": {
    "href": "articles/join_spectate/join.html",
    "title": "ToDo | Discord RPC C#",
    "keywords": "ToDo Documentation is current not written for this subject Help Wanted Here Contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "articles/join_spectate/join_requests.html": {
    "href": "articles/join_spectate/join_requests.html",
    "title": "ToDo | Discord RPC C#",
    "keywords": "ToDo Documentation is current not written for this subject Help Wanted Here Contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "articles/join_spectate/spectate.html": {
    "href": "articles/join_spectate/spectate.html",
    "title": "ToDo | Discord RPC C#",
    "keywords": "ToDo Documentation is current not written for this subject Help Wanted Here Contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "articles/rich_presence/guidelines.html": {
    "href": "articles/rich_presence/guidelines.html",
    "title": "ToDo | Discord RPC C#",
    "keywords": "ToDo Documentation is current not written for this subject Help Wanted Here Contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "articles/rich_presence/intro.html": {
    "href": "articles/rich_presence/intro.html",
    "title": "Rich Presence | Discord RPC C#",
    "keywords": "Rich Presence Rich Presence needs to be initially setup on your Discord Developer Portal and it's recommended to follow the Best Practices . Help Wanted Here Contribute with what you know and how you did it with a new PR on the GitHub Repository"
  },
  "index.html": {
    "href": "index.html",
    "title": "Discord Rich Presence | Discord RPC C#",
    "keywords": "Discord Rich Presence This is a C# implementation of the Discord RPC library which was originally written in C++. This avoids having to use the official C++ and instead provides a managed way of using the Rich Presence within the .NET environment*. While the official C++ library has been deprecated, this library has continued support and development for all your Rich Presence need, without requiring the Game SDK. Here are some key features of this library: Message Queuing Threaded Reads Managed Pipes * Error Handling & Error Checking with automatic reconnects Events from Discord (such as presence update and join requests) Full Rich Presence Implementation (including Join / Spectate) Inline Documented (for all your IntelliSense needs) Helper Functionality (eg: AvatarURL generator from Join Requests) Ghost Prevention (Tells Discord to clear the RP on disposal) Full Unity3D Editor (Contains all the tools, inspectors and helpers for a Unity3D game all in one package). Documentation All the documentation can be found lachee.github.io/discord-rpc-csharp/docs/ Installation Dependencies: Newtonsoft.Json .NET Standard 2.0 .NET Project For projects that target either .NET Core or .NETFX, you can get the package on nuget : PM> Install-Package DiscordRichPresence You can also Download or Build your own version of the library if you have more specific requirements. Unity3D Game Engine Unity Package is being moved to Lachee/Discord-RPC-Unity . Please check the releases / documentation there. Usage The Discord.Example project within the solution contains example code, showing how to use all available features. For Unity Specific examples, check out the example project included. There are 3 important stages of usage, Initialization, Invoking and Deinitialization. It's important you follow all 3 stages to ensure proper behaviour of the library. Initialization This stage will setup the connection to Discord and establish the events. Once you have done the initialization you can call SetPresence and other variants as many times as you wish throughout your code. Please note that ideally this should only run once, otherwise conflicts may occur with them trying to access the same Discord client at the same time. public DiscordRpcClient client; //Called when your application first starts. //For example, just before your main loop, on OnEnable for unity. void Initialize() { /* Create a Discord client NOTE: If you are using Unity3D, you must use the full constructor and define the pipe connection. */ client = new DiscordRpcClient(\"my_client_id\"); //Set the logger client.Logger = new ConsoleLogger() { Level = LogLevel.Warning }; //Subscribe to events client.OnReady += (sender, e) => { Console.WriteLine(\"Received Ready from user {0}\", e.User.Username); }; client.OnPresenceUpdate += (sender, e) => { Console.WriteLine(\"Received Update! {0}\", e.Presence); }; //Connect to the RPC client.Initialize(); //Set the rich presence //Call this as many times as you want and anywhere in your code. client.SetPresence(new RichPresence() { Details = \"Example Project\", State = \"csharp example\", Assets = new Assets() { LargeImageKey = \"image_large\", LargeImageText = \"Lachee's Discord IPC Library\", SmallImageKey = \"image_small\" } }); } Invoking Invoking is optional. Use this when thread safety is paramount. The client will store messages from the pipe and won't invoke them until you call Invoke() or DequeueMessages() . It does this because the pipe is working on another thread, and manually invoking ensures proper thread safety and order of operations (especially important in Unity3D applications). In order to enable this method of event calling, you need to set it in the constructor of the DiscordRpcClient under autoEvents . //The main loop of your application, or some sort of timer. Literally the Update function in Unity3D void Update() { //Invoke all the events, such as OnPresenceUpdate client.Invoke(); }; Here is an example on how a Timer could be used to invoke the events for a WinForm var timer = new System.Timers.Timer(150); timer.Elapsed += (sender, args) => { client.Invoke(); }; timer.Start(); Deinitialization It's important that you dispose your client before your application terminates. This will stop the threads, abort the pipe reads, and tell Discord to clear the presence. Failure to do so may result in a memory leak! //Called when your application terminates. //For example, just after your main loop, on OnDisable for unity. void Deinitialize() { client.Dispose(); } Building DiscordRPC Library dotnet build -c Release Unity3D If you wish to have barebones Unity3D implementation, you need to build the DiscordRPC.dll , the Unity Named Pipes Library and the UnityNamedPipe.cs . Put these in your own Unity Project and the .dll s in a folder called Plugins . UWP / .NET MAUI / WIN UI 3 For now, the library doesn't work on UWP applications until we find the issue and fix it. In order to make this library work with the WIN UI 3 related applications such as .NET MAUI, you need to define runFullTrust Capability inside Package.appxmanifest . Here is an example of how to add runFullTrust to your WIN UI 3 application: Package.appxmanifest : <?xml version=\"1.0\" encoding=\"utf-8\"?> <Package xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\" xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\" xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\" IgnorableNamespaces=\"uap rescap\"> ... <Capabilities> <rescap:Capability Name=\"runFullTrust\" /> </Capabilities> </Package> If you use .NET MAUI or WIN UI 3 template for C#, it automatically puts runFullTrust capability."
  }
}